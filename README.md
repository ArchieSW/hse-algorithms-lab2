# Лабораторная 2
| | |
|--------------- | --------------- |
| Выполнил   | Кутузов Дмитрий 21ПИ-1   |
| Логин в контесте   |  dnkutuzov@edu.hse.ru (Дмитрий Кутузов)  |
| Исходники с замерами производительности:  |  [Benchmark.cpp](./src/benchmarks/Benchmark.cpp)  |
| Исходники с контеста | [lab2.cpp](./lab2.cpp) |
| Графики и результаты замеров:   | [Google sheets](https://docs.google.com/spreadsheets/d/1flGAFltMPkYkREZPRvVBtpYqggEHKgOsAulFs_ydhzQ/edit?usp=sharing)   |

## Использование
Для компиляции используется система сборки [meson](https://mesonbuild.com/)

Компиляция:
```bash
meson setup builddir
meson compile -C builddir
```
Запуск:
```bash
./builddir/lab2 # Для запуска решения контеста
./builddir/bench # Для запуска замера производительности
```

## Описание задачи
> A. Точка среди прямоугольников
>
> Ограничение времени 	1 секунда
>
> Ограничение памяти 	256Mb
>
> Ввод 	стандартный ввод или input.txt
>
> Вывод 	стандартный вывод или output.txt
>
> Даны прямоугольники на плоскости с углами в целочисленных координатах 0≤x≤109, 0≤y≤109. Требуется как можно быстрее выдавать ответ на вопрос «Скольким прямоугольникам принадлежит точка x,y?». Если точка находится на границе прямоугольника, то считается, что она принадлежит ему. Подготовка данных должна занимать как можно меньше времени.

## Описание алгоритмов
### Переборное решение
Будет отвечать на запрос перебором всех прямоугольников. Если точка лежит в прямоугольнике, то увеличиваем  счетчик, который и отдаем.
```C++
  auto get_number_of_crossing(const Vec2d& query) -> int {
      int out = 0;
      for (auto& rectangle : rectangles) {
        if (rectangle.is_inside_without_left_and_top(query)) {
          out++;
        }
      }
      return out;
  }
```
|  Ассимптотики  |     |
|--------------- | --------------- |
| Подготовка   | *O(1)*   |
| Ответ на запрос   | *O(N)*   |
| По памяти   | *O(N)* на хранение всех прямоугольников  |


### Алгоритм на карте со сжатием координат.
Сожмем все координаты прямоугольников. Построим двумерный массив, который и будет отрисовывать наши сжатые прямоугольники. Тогда, чтобы ответить на запрос, нам нужно сжать координату точки и найти соответствующий элемент в карте.

*Подготовка:*
```C++
  void prepare_rectangles(const Rectangles& recs) {
    rectangles = recs;
    compressed_x.clear();
    compressed_y.clear();
    compress_rectangles();
    fill_map();
  }
```

*Ответ на запрос:*
```C++
  auto get_number_of_crossing(const Vec2d& query) -> int {
    Vec2d compressed = compress_point(query);
    if (compressed.x < 0 || compressed.x >= static_cast<int>(compressed_x.size()) ||
        compressed.y < 0 || compressed.y >= static_cast<int>(compressed_y.size())) {
      return 0;
    }
    return solution_map[compressed.x][compressed.y];
  }
```
|*Итоговые ассимптотики:*| |
|-------------|----------|
|Подготовка   |*O(N**3)* |
|Ответ на запрос | *O(log(N))*|
|По памяти | *O(N**2)* в худшем случае|

### Алгоритм на персистентном дереве отрезков
Сожмем координаты прямоугольников. Отсортируем прямоугольники по иксу. Далее пройдемся по всем иксам и будем добавлять в дерево [left_angle.y, top_angle.y) +1, если прямоугольник в соответствующей вершине появился и -1, если закончился. Тогда, чтобы ответить на запрос, на достаточно сжать координату точки, найти какой версии соответствует сжатая координата х и взять элемент по у в дереве.

*Персистентное дерево отрезков*
Реализация персистентности сделана по методу копирования пути.

Код можно найти тут: [PersistentSegmentTree](./src/solutions/PersistentSegmentTreeSolution.hpp)

Код решения там же.

|*Итоговые ассимптотики:* |  |
|-------------------------|--|
|Подготовка | *O(N\*log(N))* |
|Ответ на запрос | *O(log(N))* |
|По памяти | *O(N\*log(N))* в худшем случае |

## Выводы
В системе, где некритично время выполнения и небольшие данные (в пределах 50 треугольников), хорошо подходит переборных алгоритм, так как он тратит гораздо меньше памяти, не требует времени на подготовку и быстро пишется.

В системе, где критично время выполнения и небольшие данные (~150 треугольников), лучше использовать алгоритм на карте. Так как он быстрее отвечает на запрос, чем алгоритм на дереве, но больше ест памяти и дольше подготавливается.

В случае, если у нас есть время и нервы на написание персистентного дерева отрезков, у нас есть большой объем данных и нужно быстро выполнять запросы и нет времени на подготовку - идельным вариантом будет решение на персистентном до.
